# 开发问题与解决记录（memory system 迭代）

## 1. 项目级 Skills 未加载

### 现象
- 日志 `SystemMessage.init.data.skills` 里看不到新建的项目 skills。
- `slash_commands` 里也没有 `memory-capture/memory-summarize/memory-organize/memory-revise`。

### 根因
- Claude Agent SDK 默认未加载项目设置源，导致 `.claude/skills` 未进入当前会话。

### 解决方案
- 在 `ClaudeAgentOptions` 中设置：
  - `setting_sources=["project"]`
- 验证标准：
  - 日志中 `skills` 包含 4 个 memory skill。
  - `slash_commands` 同步出现 4 个 memory 命令。

---

## 2. “新对话”点击后没有真正重置会话

### 现象
- 前端传了 `new_conversation=true`，但模型仍记得上轮内容。

### 根因
- 在当前 SDK/CLI 组合下，`ClaudeSDKClient.query(..., session_id=...)` 的会话切换不稳定，不能作为可靠的新会话重置手段。

### 解决方案
- 采用“实例级重置”：
  - 同一会话复用当前 `ClaudeSDKClient`。
  - 新对话时创建新的 `ClaudeSDKClient` 实例。
- 通过 `conversation_id` 控制是否强制重建 client。

---

## 3. 新建 client 偶发初始化超时

### 现象
- 错误：`Control request timeout: initialize`

### 根因
- 加载 `user/local` 配置时会带入较多 MCP（如 github/context7/codex），初始化链路变长，超时概率上升。

### 解决方案
- 将 `setting_sources` 收敛为 `["project"]`，只保留项目级配置。
- 结果：
  - 初始化稳定性提升。
  - 项目 skills 正常加载。

---

## 4. 新对话重建后资源占用问题

### 现象
- 新 client 建立后，旧 client 若不及时销毁会继续占用资源。

### 解决方案
- 引入延迟回收机制：
  - 新对话发生时，把旧 client 放入 `STALE_CLIENTS`。
  - 后台任务延迟 20 秒执行 `disconnect`。
- 相关实现：
  - `stale_client_cleanup.py`
  - `app.py` 中 `STALE_CLEANUP_TASK` 调度与 shutdown 兜底清理。

---

## 5. 记忆系统问答偶发“无法访问记忆系统”

### 现象
- 用户询问“记忆系统总结”时，模型直接回复无法访问，而未读取本地 `memory/`。

### 根因
- 纯语义决策下，模型不一定主动调用文件工具或不一定将“记忆系统”映射到本地目录。

### 解决方案
- 增加 memory 查询增强：
  - 识别 memory 关键词（`记忆/memory/个人记忆/记忆系统`）。
  - 预读取 `memory/` 下 `.md/.yaml/.yml` 内容片段注入 prompt。
  - 明确要求先基于本地 memory 内容再总结。
- 相关实现：
  - `memory_context.py`
  - `prompt_builder.py`

---

## 6. 回答重复拼接（AssistantMessage + ResultMessage）

### 现象
- 某些请求出现回复重复两遍。

### 根因
- 同时拼接了 `AssistantMessage.content` 文本和 `ResultMessage.result` 文本，内容经常重复。

### 解决方案
- 优先使用 `AssistantMessage` 文本块。
- 仅在无文本块时回退使用 `result`。

---

## 7. 日志序列化报错

### 现象
- 错误：`Object of type TextBlock is not JSON serializable`

### 根因
- SDK 消息对象包含非 JSON 原生类型，直接 `json.dumps` 失败。

### 解决方案
- 增加深度 `json-safe` 转换（dict/list/model_dump/Path/对象兜底字符串化）。
- 相关实现：
  - `chat_logging.py`
- 增加测试覆盖：
  - `tests/test_chat_logging.py`

---

## 8. 全量 pytest 与子项目冲突

### 现象
- 运行 `pytest -q` 时出现 collection internal error（`pytest_asyncio` + 子项目环境冲突）。

### 根因
- 工作区包含独立子项目 `memory-system/`，其依赖与主项目测试插件组合冲突。

### 解决方案
- 主项目测试执行范围固定为：
  - `pytest -q tests`
- 避免扫描子项目测试与缓存目录。

---

## 9. 当前稳定策略总结

1. 项目级 skills：
   - `.claude/skills/*`
   - 通过 `setting_sources=["project"]` 生效
2. 会话策略：
   - 同会话复用当前 client
   - 新对话重建 client
   - 旧 client 20 秒后自动销毁
3. 安全策略：
   - 路径限制在工作区
   - `Bash` 默认拒绝（权限回调）
4. 观测策略：
   - 每次请求写独立 `logs/*.jsonl`
   - 记录 request/message/permission/error/response


---

## 10. “已完成但无输出”假成功（工具失败后回包误判）

### 现象
- 用户确认“需要执行优化”后，系统回复：
  - `已完成请求，但没有可显示的文本输出。`
- 随后再次追问才暴露实际失败原因（Bash 不可用），造成“看起来成功、实际未执行”。

### 根因
- 该轮对话中模型发起了 `Bash`（如 `rm/mv`）工具调用。
- 权限回调拒绝后，流中出现中断事件（`[Request interrupted by user for tool use]`）以及 `ResultMessage.subtype=error_during_execution`，同时 `result=null`。
- 旧逻辑只按“是否收集到文本块”判断，未识别“工具错误/中断”状态，误落入“已完成但无输出”分支。

### 解决方案
- 新增统一回复组装逻辑：`build_reply_text(...)`。
- 优先级调整为：
  1. 有正文文本 -> 返回正文
  2. 有工具错误 -> 返回“执行失败 + 错误原因 + 日志文件”
  3. 有中断/执行错误子类型 -> 返回“执行中断 + 日志文件”
  4. 仅在上述都不满足时，才返回“已完成但无输出”
- 相关实现：`app.py`
- 新增测试：
  - `tests/test_reply_building.py`

---

## 11. Bash 全禁用导致“只能手动操作”

### 现象
- 用户下达“删除/移动 memory 文件”的请求时，模型可给出方案，但执行阶段反复失败或退化为“请手动操作”。

### 根因
- 后端此前策略为 `Bash` 一律拒绝（`bash_disabled`）。
- 但文件重命名/移动/删除这类操作在 Claude Code 实际常通过 Bash 工具完成。
- 结果是：模型具备意图，但执行通道被完全封死。

### 解决方案
- 将 Bash 策略从“全禁用”改为“安全白名单 + 路径约束”：
  - 允许命令（示例）：`rm/mv/cp/mkdir/ls/cat`、`del/move/copy/ren`、`Remove-Item/Move-Item/Copy-Item/New-Item/Get-ChildItem`
  - 拒绝危险语法：`&&`、`||`、`;`、管道、重定向、命令替换等
  - 所有路径参数必须落在工作区根目录下
- 相关实现：
  - `app.py` 中 `validate_bash_command(...)`
  - `can_use_tool(...)` 对 Bash 走安全校验分支
- 新增测试：
  - `tests/test_bash_policy.py`

---

## 12. 本轮修复后的验证结果

### 自动化测试
- `pytest -q tests` 通过（25 passed）。

### 行为验证目标
- 当工具被拒绝或执行中断时：
  - 必须返回明确失败原因，不再“假成功”。
- 当请求为工作区内安全文件操作时：
  - Bash 可执行，支持实际完成移动/删除/重命名。

---

## 13. 当前稳定策略（更新版）

1. Skills 加载：
   - `.claude/skills/*`
   - 通过 `setting_sources=["project"]` 生效
2. 会话策略：
   - 同会话复用当前 client
   - 新对话重建 client
   - 旧 client 20 秒后自动销毁
3. 安全策略：
   - 路径限制在工作区
   - Bash 采用“安全白名单 + 路径约束”，不再全禁用
4. 观测策略：
   - 每次请求写独立 `logs/*.jsonl`
   - 记录 request/message/permission/error/response

---

## 14. memory 上下文读取的事件循环阻塞风险（资源受限场景）

### 现象
- `build_memory_context` 为同步文件 I/O，且在 FastAPI 异步请求路径中直接调用。
- 当命中 memory 查询时，会短暂阻塞事件循环，拖慢其他接口请求响应。

### 风险评估
- 现有 `CLIENT_QUERY_LOCK` 会让 Claude 查询串行执行，因此“并发打爆”风险不高。
- 但事件循环阻塞会导致请求排队感增强，表现为卡顿、慢响应，峰值时可能触发超时。

### 解决方案
- 保持 `build_memory_context` 的同步实现（简单、可控）。
- 在异步路径中改为线程池执行，避免阻塞事件循环：
  - 新增 `build_memory_context_async(root)`，内部使用 `await asyncio.to_thread(build_memory_context, root)`。
  - `run_agent(...)` 中 memory 查询分支改为调用 `await build_memory_context_async(...)`。

### 相关实现
- `app.py`：
  - 新增 `build_memory_context_async(...)`
  - `run_agent(...)` 内 memory 上下文读取改为 `await` 线程池调用

### 测试验证
- 新增测试：`tests/test_memory_context_async.py`
  - 验证异步包装函数确实通过 `asyncio.to_thread` 调用同步函数。
- 全量测试：`pytest -q tests` 通过（29 passed）。

### 结论
- 该修复不会提高 Claude 并发数（仍由 `CLIENT_QUERY_LOCK` 串行控制），
  但可避免 memory 文件读取阻塞整个事件循环，提升多请求场景下的服务流畅度。

---

## 15. memory 改为“索引优先”策略（实现 1 + 3）

### 背景
- 原实现为“预加载最多 12 个文件正文 + 12000 字符上限”。
- 问题是正文预加载成本高、容易截断，且不利于让 Agent 先做全局判断。

### 目标
- 实现“先看目录索引，再按需读正文”。
- 自动维护索引，避免索引与文件状态不一致。

### 实现内容
1. 新增索引模块：`memory_index.py`
- 新增 `write_memory_index(root)`：生成 `memory/_index.yaml`
- 索引字段包含：`path/title/type/tags/updated_at/mtime/size/summary`
- 文件按 `mtime` 倒序，优先最近变更内容
- 索引文件自身 `_index.yaml` 不参与索引条目

2. 自动维护索引
- `ensure_memory_layout(...)` 执行后会刷新索引
- `create_inbox_note(...)` 写入新记忆后会刷新索引

3. 上下文改为索引注入
- `build_memory_context(...)` 改为读取并输出索引条目（不再预加载正文片段）
- `run_agent(...)` 改为每次对话注入索引上下文，提示 Agent 先基于索引判断再按需 Read 正文

### 测试
- 新增：`tests/test_memory_index.py`
- 更新：`tests/test_memory_stage1.py`
- 更新：`tests/test_memory_context.py`
- 全量：`pytest -q tests` 通过（31 passed）

### 结果
- token 与上下文体积显著下降
- 避免正文硬截断引起的语义破坏
- 保留 Agent 自主检索能力（按需再读文件正文）

---

## 16. 索引污染与系统文档误收录（2026-02-15）

### 问题 1：索引文件被再次索引
- 现象：`memory/_index.yaml`（历史遗留）被当作普通记忆文件收录，出现“索引包含索引”污染。
- 原因：扫描逻辑仅排除当前索引文件名，未兼容历史索引文件名。
- 解决：在索引扫描中统一排除 `_index.json` 与 `_index.yaml`。

### 问题 2：系统文档被当作记忆数据
- 现象：`memory/MEMORY_SCHEMA.md` 被纳入索引，影响检索语义。
- 原因：扫描逻辑仅按后缀过滤，缺少系统文件排除规则。
- 解决：加入系统文件排除清单：`MEMORY_SCHEMA.md`、`README.md`。

### 问题 3：新旧索引文件并存
- 现象：`memory/_index.json` 与 `memory/_index.yaml` 同时存在，容易混淆。
- 解决：删除旧 `memory/_index.yaml`，统一保留 `memory/_index.json`。

### 验证
- 已新增/更新测试覆盖上述场景。
- 全量测试：`pytest -q tests` 通过（34 passed）。

---

## 17. 飞书对接（Webhook 模式）接入

### 目标
- 基于现有 FastAPI 项目接入飞书消息入口，复用当前 Claude Code 对话能力。

### 实现
- 新增 `feishu_client.py`：
  - 调用 `tenant_access_token/internal` 获取租户 token
  - 调用 `im/v1/messages` 回发文本消息
  - 解析飞书文本消息内容
- 新增接口：`POST /api/feishu/webhook`
  - 支持飞书 challenge 校验
  - 支持文本事件：收到消息 -> 调用 `run_agent` -> 回发飞书
- 配置项纳入 `.env` 与运行配置：
  - `FEISHU_APP_ID`
  - `FEISHU_APP_SECRET`

### 测试
- 新增：`tests/test_feishu_integration_api.py`
- 全量：`pytest -q tests` 通过（36 passed）

### 说明
- 当前采用 HTTP Webhook 模式（简化、易部署），未接入 `lark-oapi` websocket 长连接模式。

---

## 18. 飞书本地接入方式修正（Webhook -> 长连接）

### 现象
- 飞书侧发消息无回复。
- 本地 Web 后端可用，但飞书事件无法稳定触达处理链路。

### 根因
- 初版采用 HTTP Webhook 方案，天然要求飞书可访问到公网回调地址。
- 本项目是本地记忆系统，未暴露公网地址时，Webhook 方案不可用。

### 解决方案
- 对齐 `memory-system` 的接入方式，改为飞书长连接（WebSocket）模式：
  - 新增并重构 `feishu_ws_bridge.py`
  - 使用 `lark-oapi` 的 `ws.Client` 收事件
  - 事件回调中复用现有 `run_agent(...)` 能力并回发消息
  - 增加收发与异常日志：`logs/feishu_ws_bridge.log`
- 接入并支持以下配置：
  - `FEISHU_APP_ID`
  - `FEISHU_APP_SECRET`
  - `FEISHU_ENCRYPT_KEY`
  - `FEISHU_VERIFICATION_TOKEN`

### 验证结果
- 飞书消息已可正常收到并回复（本地模式，无需公网回调地址）。
- 测试仍通过：`pytest -q tests`（36 passed）。

### 当前推荐运行方式
1. 启动 Web 服务：`python -m uvicorn app:app --host 127.0.0.1 --port 8000`
2. 启动飞书桥接：`python feishu_ws_bridge.py`

---

## 19. 服务收敛与结构优化（2026-02-15）

### 目标
- 清理已弃用的 Feishu webhook 残余代码，统一为本地长连接模式。
- 降低维护复杂度，避免双入口（webhook + websocket）并存导致排障困难。

### 调整内容
1. 后端删除 `POST /api/feishu/webhook` 路由。
2. 删除旧模块 `feishu_client.py`（token 获取 + HTTP 回发逻辑）。
3. 删除旧测试 `tests/test_feishu_integration_api.py`。
4. 新增验证测试 `tests/test_feishu_webhook_removed.py`，确保 webhook 路由返回 404。
5. 更新 `README.md`，明确 Feishu 仅通过 `feishu_ws_bridge.py` 接入。

### 结果
- Feishu 接入路径单一：`feishu_ws_bridge.py -> run_agent(...) -> 飞书回发`。
- 代码结构更清晰，减少重复链路和歧义配置。
- 后续排障只需关注桥接进程日志：`logs/feishu_ws_bridge.log`。

---

## 20. 依赖管理切换到 uv（2026-02-15）

### 目标
- 统一项目依赖管理方式，避免全局环境污染。

### 调整
1. 新增 `pyproject.toml` 作为依赖单一事实来源。
2. 使用 `dependency-groups.dev` 管理测试依赖（`pytest`）。
3. 删除 `requirements.txt`，避免双维护。
4. `README.md` 启动与测试命令改为：
   - `uv sync --dev`
   - `uv run uvicorn app:app --reload --port 8000`
   - `uv run python feishu_ws_bridge.py`
   - `uv run pytest`

### 结果
- 项目可在隔离虚拟环境下稳定复现依赖。
- 本地与服务器环境一致性更高。

---

## 21. uv 启动在 sandbox 下的权限问题（2026-02-16）

### 现象
- 在受限 sandbox 环境启动服务时，`uv run uvicorn app:app --reload --port 8000` 失败。
- 典型报错：
  - `failed to open file ... AppData\\Local\\uv\\cache ... (os error 5)`
  - `PermissionError: [WinError 5] 拒绝访问`（`multiprocessing.resource_sharer` / `CreateNamedPipe`）

### 根因
- `uv` 默认缓存目录位于用户目录（`AppData\\Local\\uv\\cache`），在受限环境下不可写或不可访问。
- `uvicorn --reload` 会启用重载监控与多进程机制，在受限权限下更容易触发命名管道访问失败。

### 解决方案
1. 将缓存目录显式切换到项目内可写目录：
   - `UV_CACHE_DIR=D:\\develop\\claude-memory-system\\.uv-cache`
2. 启动服务时去掉 `--reload`，改为：
   - `uv run uvicorn app:app --host 127.0.0.1 --port 8000`
3. 需要联网安装依赖（如飞书桥接首次启动）时，使用沙箱外执行授权。

### 验证结果
- `127.0.0.1:8000` 监听成功。
- HTTP 探测返回 `200`。
- `v1` 分支下 `uv run python feishu_ws_bridge.py` 在依赖下载完成后可正常运行。

---

## 22. Claude 会话在重启后未恢复（2026-02-19）

### 现象
- 服务重启后，Claude 对话看起来像“新会话”，无法延续之前上下文。
- 用户侧期望是“默认持续同一会话”，需要时通过 `/clear` 或 `/compact` 主动重置。

### 根因
1. SDK 调用未显式传 `session_id`  
- 之前代码调用 `client.query(effective_prompt)`，未把业务层 `conversation_id` 传入 SDK。

2. 缺少稳定默认会话 ID  
- 当请求未传 `conversation_id` 且未显式 `new_conversation` 时，旧逻辑会生成随机 UUID，导致每次都像新会话。

### 方案
1. 默认会话策略改为固定主会话
- `conversation_session.py`
- `DEFAULT_SESSION_ID` 从随机兜底改为固定 `"main"`。
- 行为：未传 `conversation_id` 且 `new_conversation=false` 时，复用 `main`。

2. SDK 查询显式透传会话 ID
- `app.py` 的 `run_agent(...)` 中改为：
  - `client.query(effective_prompt, session_id=conversation_id)`

3. 保留主动重置能力
- 日常默认复用主会话；
- 需要清上下文时，使用 `/clear`、`/compact`（产品层约定）。

### 测试与验证
- 更新测试：`tests/test_conversation_session.py`
  - 断言缺省会话为 `main` 且 `is_new_session=False`。
- 新增测试：`tests/test_run_agent_session_id.py`
  - 断言 `run_agent` 会把 `conversation_id` 透传到 SDK 的 `session_id`。
- 兼容更新：`tests/test_run_agent_timeout.py`
  - fake client 的 `query` 签名增加 `session_id` 参数。

### 结果
- 默认行为从“隐式新会话”变为“显式复用主会话（main）”。
- 会话连续性符合产品预期，降低重启后的上下文割裂感。

---

## 23. 飞书中的 `/clear`/`/compact` 未生效（2026-02-20）

### 现象
- 在飞书发送 `/clear` 后，机器人回复“已清空”，但继续追问时仍能回忆上文。
- `/compact` 在飞书中也无法按预期执行。

### 根因
1. 飞书桥接层未实现这两个命令的拦截分支。  
2. 消息被当普通文本发给模型，模型会“解释命令”而非“执行命令”，出现假执行反馈。

### 解决方案
1. 新增会话命令处理器（桥接层硬处理）  
- 文件：`feishu_ws_bridge.py`  
- 新增：
  - `handle_session_command(text, chat_id)`
  - `_resolve_chat_conversation_id(chat_id)`
  - `_clear_chat_session(chat_id)`
  - 会话状态持久化文件：`logs/feishu_chat_sessions.json`

2. `/clear` 真正重置飞书会话  
- 将 `chat_id` 对应会话代际 `vN` +1。  
- 后续消息会进入新会话 `feishu:{chat_id}:v{N+1}`。

3. `/compact` 明确降级提示  
- 当前桥接返回明确说明：飞书通道暂不支持 Claude CLI 内置 `/compact`，避免误导性“已执行”。

### 测试
- 新增：`tests/test_feishu_session_commands.py`
  - `/clear` 不会调用 `run_agent`
  - `/clear` 后下一条消息的会话 ID 从 `v0` 变为 `v1`
  - `/compact` 不会调用 `run_agent`，且返回明确提示

### 结果
- 飞书中的 `/clear` 从“语义假执行”变为“桥接层真执行”。
- 用户不会再看到“看起来清空但实际没清空”的错觉。 
