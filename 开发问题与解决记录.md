# 开发问题与解决记录（memory system 迭代）

## 1. 项目级 Skills 未加载

### 现象
- 日志 `SystemMessage.init.data.skills` 里看不到新建的项目 skills。
- `slash_commands` 里也没有 `memory-capture/memory-summarize/memory-organize/memory-revise`。

### 根因
- Claude Agent SDK 默认未加载项目设置源，导致 `.claude/skills` 未进入当前会话。

### 解决方案
- 在 `ClaudeAgentOptions` 中设置：
  - `setting_sources=["project"]`
- 验证标准：
  - 日志中 `skills` 包含 4 个 memory skill。
  - `slash_commands` 同步出现 4 个 memory 命令。

---

## 2. “新对话”点击后没有真正重置会话

### 现象
- 前端传了 `new_conversation=true`，但模型仍记得上轮内容。

### 根因
- 在当前 SDK/CLI 组合下，`ClaudeSDKClient.query(..., session_id=...)` 的会话切换不稳定，不能作为可靠的新会话重置手段。

### 解决方案
- 采用“实例级重置”：
  - 同一会话复用当前 `ClaudeSDKClient`。
  - 新对话时创建新的 `ClaudeSDKClient` 实例。
- 通过 `conversation_id` 控制是否强制重建 client。

---

## 3. 新建 client 偶发初始化超时

### 现象
- 错误：`Control request timeout: initialize`

### 根因
- 加载 `user/local` 配置时会带入较多 MCP（如 github/context7/codex），初始化链路变长，超时概率上升。

### 解决方案
- 将 `setting_sources` 收敛为 `["project"]`，只保留项目级配置。
- 结果：
  - 初始化稳定性提升。
  - 项目 skills 正常加载。

---

## 4. 新对话重建后资源占用问题

### 现象
- 新 client 建立后，旧 client 若不及时销毁会继续占用资源。

### 解决方案
- 引入延迟回收机制：
  - 新对话发生时，把旧 client 放入 `STALE_CLIENTS`。
  - 后台任务延迟 20 秒执行 `disconnect`。
- 相关实现：
  - `stale_client_cleanup.py`
  - `app.py` 中 `STALE_CLEANUP_TASK` 调度与 shutdown 兜底清理。

---

## 5. 记忆系统问答偶发“无法访问记忆系统”

### 现象
- 用户询问“记忆系统总结”时，模型直接回复无法访问，而未读取本地 `memory/`。

### 根因
- 纯语义决策下，模型不一定主动调用文件工具或不一定将“记忆系统”映射到本地目录。

### 解决方案
- 增加 memory 查询增强：
  - 识别 memory 关键词（`记忆/memory/个人记忆/记忆系统`）。
  - 预读取 `memory/` 下 `.md/.yaml/.yml` 内容片段注入 prompt。
  - 明确要求先基于本地 memory 内容再总结。
- 相关实现：
  - `memory_context.py`
  - `prompt_builder.py`

---

## 6. 回答重复拼接（AssistantMessage + ResultMessage）

### 现象
- 某些请求出现回复重复两遍。

### 根因
- 同时拼接了 `AssistantMessage.content` 文本和 `ResultMessage.result` 文本，内容经常重复。

### 解决方案
- 优先使用 `AssistantMessage` 文本块。
- 仅在无文本块时回退使用 `result`。

---

## 7. 日志序列化报错

### 现象
- 错误：`Object of type TextBlock is not JSON serializable`

### 根因
- SDK 消息对象包含非 JSON 原生类型，直接 `json.dumps` 失败。

### 解决方案
- 增加深度 `json-safe` 转换（dict/list/model_dump/Path/对象兜底字符串化）。
- 相关实现：
  - `chat_logging.py`
- 增加测试覆盖：
  - `tests/test_chat_logging.py`

---

## 8. 全量 pytest 与子项目冲突

### 现象
- 运行 `pytest -q` 时出现 collection internal error（`pytest_asyncio` + 子项目环境冲突）。

### 根因
- 工作区包含独立子项目 `memory-system/`，其依赖与主项目测试插件组合冲突。

### 解决方案
- 主项目测试执行范围固定为：
  - `pytest -q tests`
- 避免扫描子项目测试与缓存目录。

---

## 9. 当前稳定策略总结

1. 项目级 skills：
   - `.claude/skills/*`
   - 通过 `setting_sources=["project"]` 生效
2. 会话策略：
   - 同会话复用当前 client
   - 新对话重建 client
   - 旧 client 20 秒后自动销毁
3. 安全策略：
   - 路径限制在工作区
   - `Bash` 默认拒绝（权限回调）
4. 观测策略：
   - 每次请求写独立 `logs/*.jsonl`
   - 记录 request/message/permission/error/response


---

## 10. “已完成但无输出”假成功（工具失败后回包误判）

### 现象
- 用户确认“需要执行优化”后，系统回复：
  - `已完成请求，但没有可显示的文本输出。`
- 随后再次追问才暴露实际失败原因（Bash 不可用），造成“看起来成功、实际未执行”。

### 根因
- 该轮对话中模型发起了 `Bash`（如 `rm/mv`）工具调用。
- 权限回调拒绝后，流中出现中断事件（`[Request interrupted by user for tool use]`）以及 `ResultMessage.subtype=error_during_execution`，同时 `result=null`。
- 旧逻辑只按“是否收集到文本块”判断，未识别“工具错误/中断”状态，误落入“已完成但无输出”分支。

### 解决方案
- 新增统一回复组装逻辑：`build_reply_text(...)`。
- 优先级调整为：
  1. 有正文文本 -> 返回正文
  2. 有工具错误 -> 返回“执行失败 + 错误原因 + 日志文件”
  3. 有中断/执行错误子类型 -> 返回“执行中断 + 日志文件”
  4. 仅在上述都不满足时，才返回“已完成但无输出”
- 相关实现：`app.py`
- 新增测试：
  - `tests/test_reply_building.py`

---

## 11. Bash 全禁用导致“只能手动操作”

### 现象
- 用户下达“删除/移动 memory 文件”的请求时，模型可给出方案，但执行阶段反复失败或退化为“请手动操作”。

### 根因
- 后端此前策略为 `Bash` 一律拒绝（`bash_disabled`）。
- 但文件重命名/移动/删除这类操作在 Claude Code 实际常通过 Bash 工具完成。
- 结果是：模型具备意图，但执行通道被完全封死。

### 解决方案
- 将 Bash 策略从“全禁用”改为“安全白名单 + 路径约束”：
  - 允许命令（示例）：`rm/mv/cp/mkdir/ls/cat`、`del/move/copy/ren`、`Remove-Item/Move-Item/Copy-Item/New-Item/Get-ChildItem`
  - 拒绝危险语法：`&&`、`||`、`;`、管道、重定向、命令替换等
  - 所有路径参数必须落在工作区根目录下
- 相关实现：
  - `app.py` 中 `validate_bash_command(...)`
  - `can_use_tool(...)` 对 Bash 走安全校验分支
- 新增测试：
  - `tests/test_bash_policy.py`

---

## 12. 本轮修复后的验证结果

### 自动化测试
- `pytest -q tests` 通过（25 passed）。

### 行为验证目标
- 当工具被拒绝或执行中断时：
  - 必须返回明确失败原因，不再“假成功”。
- 当请求为工作区内安全文件操作时：
  - Bash 可执行，支持实际完成移动/删除/重命名。

---

## 13. 当前稳定策略（更新版）

1. Skills 加载：
   - `.claude/skills/*`
   - 通过 `setting_sources=["project"]` 生效
2. 会话策略：
   - 同会话复用当前 client
   - 新对话重建 client
   - 旧 client 20 秒后自动销毁
3. 安全策略：
   - 路径限制在工作区
   - Bash 采用“安全白名单 + 路径约束”，不再全禁用
4. 观测策略：
   - 每次请求写独立 `logs/*.jsonl`
   - 记录 request/message/permission/error/response

---

## 14. memory 上下文读取的事件循环阻塞风险（资源受限场景）

### 现象
- `build_memory_context` 为同步文件 I/O，且在 FastAPI 异步请求路径中直接调用。
- 当命中 memory 查询时，会短暂阻塞事件循环，拖慢其他接口请求响应。

### 风险评估
- 现有 `CLIENT_QUERY_LOCK` 会让 Claude 查询串行执行，因此“并发打爆”风险不高。
- 但事件循环阻塞会导致请求排队感增强，表现为卡顿、慢响应，峰值时可能触发超时。

### 解决方案
- 保持 `build_memory_context` 的同步实现（简单、可控）。
- 在异步路径中改为线程池执行，避免阻塞事件循环：
  - 新增 `build_memory_context_async(root)`，内部使用 `await asyncio.to_thread(build_memory_context, root)`。
  - `run_agent(...)` 中 memory 查询分支改为调用 `await build_memory_context_async(...)`。

### 相关实现
- `app.py`：
  - 新增 `build_memory_context_async(...)`
  - `run_agent(...)` 内 memory 上下文读取改为 `await` 线程池调用

### 测试验证
- 新增测试：`tests/test_memory_context_async.py`
  - 验证异步包装函数确实通过 `asyncio.to_thread` 调用同步函数。
- 全量测试：`pytest -q tests` 通过（29 passed）。

### 结论
- 该修复不会提高 Claude 并发数（仍由 `CLIENT_QUERY_LOCK` 串行控制），
  但可避免 memory 文件读取阻塞整个事件循环，提升多请求场景下的服务流畅度。
